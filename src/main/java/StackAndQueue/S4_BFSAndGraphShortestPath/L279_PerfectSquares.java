package StackAndQueue.S4_BFSAndGraphShortestPath;

import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;

import static Utils.Helpers.Pair;
import static Utils.Helpers.log;

/*
 * Perfect Squares
 *
 * - Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...)
 *   which sum to n.
 * */

public class L279_PerfectSquares {
    /*
     * è§£æ³•1ï¼šBFSï¼ˆå€ŸåŠ© Queue å®ç°ï¼‰
     * - æ€è·¯ï¼š"æ­£æ•´æ•° n æœ€å°‘èƒ½ç”¨å‡ ä¸ªå®Œå…¨å¹³æ–¹æ•°ç»„æˆ"ï¼Œè¿™ä¸ªé—®é¢˜å¯ä»¥è½¬åŒ–ä¸º"æ­£æ•´æ•° n æœ€å°‘å‡å»å‡ ä¸ªå®Œå…¨å¹³æ–¹æ•°åç­‰äº0"ã€‚è‹¥æŠŠ nã€0
     *   çœ‹æˆå›¾ä¸Šçš„ä¸¤ä¸ªé¡¶ç‚¹ï¼ŒæŠŠ"å‡å»ä¸€ä¸ªå®Œå…¨å¹³æ–¹æ•°"çœ‹åšä¸¤ç‚¹é—´çš„ä¸€æ¡è¾¹ï¼Œåˆ™è¯¥é—®é¢˜å¯è½¬åŒ–ä¸º"æ±‚é¡¶ç‚¹ n åˆ° 0 ä¹‹é—´çš„æœ€çŸ­è·¯å¾„"ï¼Œå³å°†åŸ
     *   é—®é¢˜è½¬åŒ–ä¸ºäº†ä¸€ä¸ªåœ¨æœ‰å‘æ— æƒå›¾ä¸Šå¯»æ‰¾ n â†’ 0 é—´æœ€çŸ­è·¯å¾„çš„é—®é¢˜ã€‚ä¾‹å¦‚ï¼š
     *          â“ª â† â“µ â† â‘¡              â“ª â† â‘  â† â‘¡              â“ª â† â‘  â† â† â† â‘¡
     *          â†‘         â†‘              â†‘    â†‘    â†‘               â†‘   â†‘     â†—  â†‘
     *          â“¸  â†’  â†’  â“·              â†‘   â‘¤    â†‘               â†‘   â‘¤ â† â‘¥   â†‘
     *         n=4 æ—¶æœ€çŸ­è·¯å¾„ä¸º1           â†‘    â†“    â†‘               â†‘   â†“        â†‘
     *                                   +  â† â‘£ â†’ â‘¢               + â† â‘£ â†’ â†’ â†’ â‘¢
     *                                 n=5 æ—¶æœ€çŸ­è·¯å¾„ä¸º2            n=6 æ—¶æœ€çŸ­è·¯å¾„ä¸º3
     * - ğŸ’ è¦ç‚¹ï¼š
     *   1. æ±‚æ— æƒå›¾ä¸­ä¸¤ç‚¹çš„æœ€çŸ­è·¯å¾„å¯ä½¿ç”¨ BFSï¼ˆè‹¥æ˜¯å¸¦æƒå›¾çš„æœ€çŸ­è·¯å¾„é—®é¢˜åˆ™å¯ä½¿ç”¨ Dijkstraï¼‰ï¼›
     *   2. æ— æƒå›¾ä¸Šè¿›è¡Œçš„ BFS æ—¶ï¼Œç¬¬ä¸€æ¬¡è®¿é—®æŸä¸ªé¡¶ç‚¹æ—¶çš„è·¯å¾„ä¸€å®šæ˜¯ä»èµ·ç‚¹åˆ°è¯¥é¡¶ç‚¹çš„æœ€çŸ­è·¯å¾„ï¼ˆå½“ç„¶å¯èƒ½å­˜åœ¨å¤šä¸ªæœ€çŸ­è·¯å¾„ï¼Œ
     *      å¦‚ğŸ‘†n=6 çš„ä¾‹å­ä¸­ 6 â†’ 5 â†’ 1 â†’ 0 å’Œ 6 â†’ 2 â†’ 1 â†’ 0 éƒ½æ˜¯æœ€çŸ­è·¯å¾„ï¼‰ã€‚
     *   3. æ³¨æ„é¿å…é‡å¤è®¿é—®é¡¶ç‚¹ï¼Œå¦‚ 6 â†’ 5 â†’ 1 å’Œ 6 â†’ 2 â†’ 1ï¼Œè‹¥æ²¡æœ‰ visited æ•°ç»„ï¼Œåˆ™é¡¶ç‚¹1ä¼šè¢«å…¥é˜Ÿã€å¤„ç†ä¸¤éã€‚
     * - æ—¶é—´å¤æ‚åº¦ O(n * sqrt(n))ï¼Œç©ºé—´å¤æ‚åº¦ O(n)ã€‚
     * */
    public static int numSquares(int n) {
        if (n <= 0) return 0;

        Queue<Pair<Integer, Integer>> q = new LinkedList<>();  // Pair<é¡¶ç‚¹, ä»èµ·ç‚¹åˆ°è¯¥é¡¶ç‚¹çš„æ­¥æ•°>
        q.offer(new Pair<>(n, 0));                             // é¡¶ç‚¹ n ä½œä¸º BFS çš„èµ·ç‚¹
        boolean[] visited = new boolean[n + 1];                // âˆµ é¡¶ç‚¹å–å€¼èŒƒå›´æ˜¯ [0,n] âˆ´ è¦å¼€ n+1 çš„ç©ºé—´
        visited[n] = true;

        while (!q.isEmpty()) {
            Pair<Integer, Integer> pair = q.poll();
            int curr = pair.getKey();
            int step = pair.getValue();

            for (int i = 1; i * i <= curr; i++) {  // å½“å‰é¡¶ç‚¹å€¼ - æ¯ä¸€ä¸ªå®Œå…¨å¹³æ–¹æ•° = æ¯ä¸€ä¸ªç›¸é‚»é¡¶ç‚¹
                int next = curr - i * i;
                if (next == 0) return step + 1;    // BFS ä¸­ç¬¬ä¸€æ¡åˆ°è¾¾ç»ˆç‚¹çš„è·¯å¾„å°±æ˜¯æœ€çŸ­è·¯å¾„
                if (!visited[next]) {
                    q.offer(new Pair<>(next, step + 1));
                    visited[next] = true;
                }
            }
        }

        throw new IllegalStateException("No Solution.");  // åªè¦ n æœ‰æ•ˆå°±ä¸ä¼šèµ°åˆ°è¿™é‡Œ âˆµ æ‰€æœ‰æ­£æ•´æ•°éƒ½å¯ä»¥ç”¨ n ä¸ª1ç›¸åŠ å¾—åˆ°
    }

    /*
     * è¶…æ—¶è§£ï¼šDFS
     * - æ€è·¯ï¼šæ²¿ç”¨è§£æ³•1ä¸­çš„å›¾è®ºå»ºæ¨¡æ€è·¯ã€‚
     * - å®ç°ï¼šé‡‡ç”¨ DFSï¼Œå³ä»é¡¶ç‚¹ n å¼€å§‹å‘0é¡¶ç‚¹æ–¹å‘é€’å½’æŸ¥æ‰¾ âˆµ å‰ä¸€é¡¶ç‚¹åˆ°è¾¾0çš„æœ€å°‘æ­¥æ•° = åä¸€é¡¶ç‚¹åˆ°è¾¾0çš„æœ€å°‘æ­¥æ•° + 1ï¼Œä¸”åä¸€
     *   é¡¶ç‚¹å€¼ä¸å‰ä¸€é¡¶ç‚¹å€¼ä¹‹é—´å·®ä¸€ä¸ªå®Œå…¨å¹³æ–¹æ•° âˆ´ æœ‰ f(i) = min(f(i - p) + 1)ï¼Œå…¶ä¸­ p ä¸º <= i çš„å®Œå…¨å¹³æ–¹æ•°ã€‚
     * - æ—¶é—´å¤æ‚åº¦ O(n^n)ï¼Œç©ºé—´å¤æ‚åº¦ O(n)ã€‚
     * */
    public static int numSquares_1(int n) {
        if (n <= 1) return n;             // n=0/1 æ—¶ï¼Œåˆ°è¾¾0çš„æ­¥æ•°åˆ†åˆ«ä¸º0/1

        int minStep = Integer.MAX_VALUE;  // ç”¨äºè®°å½•å½“å‰é¡¶ç‚¹åˆ°0çš„æœ€å°æ­¥æ•°
        for (int i = 1; i * i <= n; i++)  // æ‰¾åˆ°å½“å‰é¡¶ç‚¹çš„ç›¸é‚»é¡¶ç‚¹
            minStep = Math.min(minStep, numSquares_1(n - i * i) + 1);  // è®¡ç®—æ‰€æœ‰ç›¸é‚»é¡¶ç‚¹åˆ°0çš„æœ€å°‘æ­¥æ•°ï¼Œå…¶ä¸­æœ€å°å€¼+1å³æ˜¯å½“å‰é¡¶ç‚¹åˆ°0çš„æœ€å°‘æ­¥æ•°

        return minStep;
    }

    /*
     * è§£æ³•2ï¼šRecursion + Memoizationï¼ˆDFS with cacheï¼‰
     * - æ€è·¯ï¼šğŸ‘†è¶…æ—¶è§£çš„é—®é¢˜åœ¨äºå¤§é‡å­é—®é¢˜ä¼šè¢«é‡å¤è®¡ç®— âˆ´ åŠ å…¥ Memoization æœºåˆ¶æ¥ä¼˜åŒ–é‡å å­é—®é¢˜ã€‚
     * - æ—¶é—´å¤æ‚åº¦ O(n)ï¼Œç©ºé—´å¤æ‚åº¦ O(n)ã€‚
     * */
    public static int numSquares2(int n) {
        int[] minSteps = new int[n + 1];  // minSteps[i] ä¿å­˜é¡¶ç‚¹ i åˆ°0çš„æœ€å°‘æ­¥æ•°ï¼ˆâˆµ é¡¶ç‚¹å–å€¼èŒƒå›´æ˜¯ [0,n] âˆ´ è¦å¼€ n+1 çš„ç©ºé—´ï¼‰
        Arrays.fill(minSteps, -1);
        minSteps[0] = 0;
        minSteps[1] = 1;
        return helper2(n, minSteps);
    }

    private static int helper2(int n, int[] minSteps) {
        if (minSteps[n] != -1) return minSteps[n];  // cache hit

        int minStep = Integer.MAX_VALUE;
        for (int i = 1; i * i <= n; i++)
            minStep = Math.min(minStep, helper2(n - i * i, minSteps) + 1);

        return minSteps[n] = minStep;  // èµ‹å€¼è¯­å¥çš„è¿”å›å€¼ä¸ºæ‰€èµ‹çš„å€¼
    }

    /*
     * è§£æ³•3ï¼šDP
     * - æ€è·¯ï¼šä¸è§£æ³•2ä¸€æ ·éƒ½æ˜¯åŸºäºå·²è§£å†³çš„å­é—®é¢˜å»è§£å†³é«˜å±‚æ¬¡çš„é—®é¢˜ã€‚çŠ¶æ€è½¬ç§»æ–¹ç¨‹éƒ½æ˜¯ï¼šf(i) = min(f(i - p) + 1)ï¼Œ
     *   å…¶ä¸­ p ä¸º <= i çš„å®Œå…¨å¹³æ–¹æ•°ã€‚
     * - å®ç°ï¼šé‡‡ç”¨ DP ä»ä¸‹å¾€ä¸Š f(0) â†’ f(1) â†’ ... é€’å½’å‡º f(n) çš„è§£ï¼Œä¾‹å¦‚ n=6 æ—¶ï¼š
     *         +---------------------+
     *         |           â‘¥        â‘¢     - dp[6] = min(dp[5]+1, dp[2]+1); dp[3] = dp[2]+1
     *         |        1â†—   4â†–   1â†—
     *         |      â‘¤        â‘¡          - dp[5] = min(dp[4]+1, dp[1]+1); dp[2] = dp[1]+1
     *          â†˜  1â†—   4â†–   1â†—
     *           â‘£        â‘                - dp[1] = dp[0]+1; dp[4] = min(dp[0]+1, dp[3]+1)
     *             4â†–   1â†—
     *                â“ª                    - dp[0] = 0
     * - ğŸ’ DP vs. Memoizationï¼šDP æ˜¯ bottom-up çš„ï¼Œä»å­é—®é¢˜å¼€å§‹æ±‚è§£ï¼Œè€Œè§£æ³•2çš„ DFS + Memorization æ˜¯ top-downï¼Œ
     *   å³å…ˆä»é«˜å±‚æ¬¡é—®é¢˜å…¥æ‰‹ï¼Œé€’å½’åˆ°æœ€åŸºæœ¬é—®é¢˜åå†å¼€å§‹å¾€ä¸Šé€å±‚è§£å†³ï¼ˆ, SEE: https://zhuanlan.zhihu.com/p/68059061ï¼‰ã€‚
     * - æ—¶é—´å¤æ‚åº¦ O(n)ï¼Œç©ºé—´å¤æ‚åº¦ O(n)ã€‚
     * */
    public static int numSquares3(int n) {
        int[] dp = new int[n + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);   // âˆµ æ±‚æœ€å°å€¼ âˆ´ åˆå€¼ä¸ºæ­£æ— ç©·
        dp[0] = 0;

        for (int i = 1; i <= n; i++)          // ä» 1â†’n é€ä¸ªè®¡ç®—åˆ°è¾¾0çš„æœ€å°‘æ­¥æ•°ï¼Œä»ä¸‹å¾€ä¸Šå±‚å±‚é€’æ¨å‡ºåŸé—®é¢˜ f(n) çš„è§£
            for (int j = 1; j * j <= i; j++)  // å¯¹äºæ¯ä¸ª i æ‰¾åˆ°ä¸å¤§äºå®ƒçš„å®Œå…¨å¹³æ–¹æ•° pï¼ˆå³ j*jï¼‰
                dp[i] = Math.min(dp[i], dp[i - j * j] + 1);

        return dp[n];
    }








    public static void main(String[] args) {
        log(numSquares0(5));   // expects 2. (5 = 4 + 1)
        log(numSquares0(6));   // expects 3. (6 = 4 + 1 + 1)
        log(numSquares0(12));  // expects 3. (12 = 4 + 4 + 4)
        log(numSquares0(13));  // expects 2. (13 = 4 + 9)
    }
}
