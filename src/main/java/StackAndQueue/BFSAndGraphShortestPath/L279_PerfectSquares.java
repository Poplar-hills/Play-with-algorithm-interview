package StackAndQueue.BFSAndGraphShortestPath;

import javafx.util.Pair;

import java.util.Arrays;
import java.util.LinkedList;
import java.util.Queue;

import static Utils.Helpers.log;

/*
* Perfect Squares
*
* - Given a positive integer n, find the least number of perfect square numbers (for example, 1, 4, 9, 16, ...)
*   which sum to n.
* */

public class L279_PerfectSquares {
    /*
    * è§£æ³•1ï¼šBFSï¼ˆå€ŸåŠ© Queue å®ç°ï¼‰
    * - æ€è·¯ï¼š"æ­£æ•´æ•° n æœ€å°‘èƒ½ç”¨å‡ ä¸ªå®Œå…¨å¹³æ–¹æ•°ç»„æˆ"ï¼Œè¿™ä¸ªé—®é¢˜å¯ä»¥è½¬åŒ–ä¸º"æ­£æ•´æ•° n æœ€å°‘å‡å»å‡ ä¸ªå®Œå…¨å¹³æ–¹æ•°åç­‰äº0"ã€‚å¦‚æœæŠŠ n å’Œ 0
    *   çœ‹æˆå›¾ä¸Šçš„ä¸¤ä¸ªé¡¶ç‚¹ï¼ŒæŠŠ"å‡å»ä¸€ä¸ªå®Œå…¨å¹³æ–¹æ•°"çœ‹åšä¸¤ç‚¹é—´çš„ä¸€æ®µè·¯å¾„ï¼Œåˆ™è¯¥é—®é¢˜å³å¯è½¬åŒ–ä¸º"æ±‚é¡¶ç‚¹ n åˆ° 0 ä¹‹é—´çš„æœ€çŸ­è·¯å¾„"ï¼Œå³å°†åŸ
    *   é—®é¢˜è½¬åŒ–ä¸ºäº†ä¸€ä¸ªå›¾è®ºé—®é¢˜ï¼Œé‡æ–°æè¿°ä¸€éå°±æ˜¯ï¼šä» n åˆ° 0ï¼Œæ¯ä¸ªæ•°å­—è¡¨ç¤ºä¸€ä¸ªé¡¶ç‚¹ï¼›è‹¥ä¸¤é¡¶ç‚¹ä¹‹é—´ç›¸å·®ä¸€ä¸ªå®Œå…¨å¹³æ–¹æ•°ï¼Œåˆ™é“¾æ¥ä¸¤é¡¶ç‚¹ï¼Œ
    *   ç”±æ­¤å¾—åˆ°ä¸€ä¸ªæœ‰å‘æ— æƒå›¾ï¼ˆæ–¹å‘éƒ½æ˜¯ä»å¤§é¡¶ç‚¹æŒ‡å‘å°é¡¶ç‚¹ï¼‰ï¼Œè¯¥é—®é¢˜æœ€ç»ˆè½¬åŒ–ä¸ºäº†æ±‚è¯¥æ— æƒå›¾ä¸­ä» n åˆ° 0 çš„æœ€çŸ­è·¯å¾„çš„æ­¥æ•°ã€‚ä¾‹å¦‚ï¼š
    *                                    0 -- 1 -- 2               0 -- 1 ---- 2
    *          0 -- 1 -- 2               |    |    |               |    |    / |
    *          |         |               |    5    |               |    5 - 6  |
    *          4 ------- 3               |    |    |               |    |      |
    *                                    +--- 4 -- 3               +--- 4 ---- 3
    *        n=4 æ—¶æœ€çŸ­è·¯å¾„ä¸º1æ­¥         n=5 æ—¶æœ€çŸ­è·¯å¾„ä¸º2æ­¥          n=6 æ—¶æœ€çŸ­è·¯å¾„ä¸º3æ­¥
    * - å®ç°ï¼šæ±‚æ— æƒå›¾ä¸­ä¸¤ç‚¹çš„æœ€çŸ­è·¯å¾„å¯ä½¿ç”¨ BFS å®ç°ï¼ˆä½†æœ‰æƒå›¾ä¸é€‚ç”¨ï¼Œå¸¦æƒå›¾çš„æœ€çŸ­è·¯å¾„å¯ä½¿ç”¨ Dijkstra ç®—æ³•ï¼‰ï¼š
    *   - ä½¿ç”¨ queue ä½œä¸ºè¾…åŠ©æ•°æ®ç»“æ„ï¼Œå³ä»èµ·ç‚¹å¼€å§‹ï¼Œå…¥é˜Ÿç›¸é‚»é¡¶ç‚¹ã€è®¿é—®å‡ºé˜Ÿçš„é¡¶ç‚¹ï¼Œå†å°†å…¶ç›¸é‚»é¡¶ç‚¹å…¥é˜Ÿï¼Œç›´åˆ°åˆ°è¾¾ç»ˆç‚¹ä¸ºæ­¢ã€‚
    *   - âˆµ æœ€ç»ˆè¦è¿”å›æ‰¾åˆ°çš„æœ€çŸ­è·¯å¾„çš„æ­¥æ•°ï¼Œå› æ­¤é˜Ÿåˆ—ä¸­é™¤äº†ä¿å­˜é¡¶ç‚¹ä¹‹å¤–è¿˜è¦ä¿å­˜æ­¥æ•°ä¿¡æ¯ã€‚
    * - æ—¶é—´å¤æ‚åº¦ O(n)ï¼Œç©ºé—´å¤æ‚åº¦ O(n)ã€‚
    * */
    public static int numSquares1(int n) {
        if (n <= 0) return 0;
        Queue<Pair<Integer, Integer>> q = new LinkedList<>();  // Pair<é¡¶ç‚¹, ä»èµ·ç‚¹åˆ°è¯¥é¡¶ç‚¹æ‰€èµ°è¿‡çš„æ­¥æ•°>
        q.offer(new Pair<>(n, 0));                 // é¡¶ç‚¹ n ä½œä¸º BFS çš„èµ·ç‚¹

        boolean[] visited = new boolean[n + 1];    // è®°å½•æŸä¸ªé¡¶ç‚¹æ˜¯å¦å·²ç»è®¡ç®—è¿‡ï¼ˆn+1 æ˜¯å› ä¸ºä» n åˆ° 0 éœ€è¦å¼€ n+1 çš„ç©ºé—´ï¼‰
        visited[n] = true;

        while (!q.isEmpty()) {
            Pair<Integer, Integer> pair = q.poll();
            int num = pair.getKey();
            int step = pair.getValue();

            for (int i = 1; i * i <= num; i++) {  // å½“å‰é¡¶ç‚¹å€¼ - æ¯ä¸€ä¸ªå®Œå…¨å¹³æ–¹æ•° = æ¯ä¸€ä¸ªç›¸é‚»é¡¶ç‚¹
                int next = num - i * i;
                if (next == 0) return step + 1;   // è‹¥ä¸‹ä¸€æ­¥åˆ°è¾¾ç»ˆç‚¹åˆ™è¿”å›è¯¥è·¯å¾„çš„æ­¥æ•°ï¼ˆç¬¬ä¸€æ¡åˆ°è¾¾ç»ˆç‚¹çš„è·¯å¾„å°±æ˜¯æœ€çŸ­è·¯å¾„æˆ–æœ€çŸ­è·¯å¾„ä¹‹ä¸€ï¼‰
                if (!visited[next]) {             // å·²è®¿é—®è¿‡é¡¶ç‚¹ä¸å…¥é˜Ÿ
                    q.offer(new Pair<>(next, step + 1));  // å…¥é˜Ÿä¸‹ä¸€æ­¥é¡¶ç‚¹
                    visited[next] = true;
                }
            }
        }
        throw new IllegalStateException("No Solution.");  // åªè¦è¾“å…¥å‚æ•°æ­£ç¡®åˆ™ä¸ä¼šåˆ°è¾¾è¿™è¡Œ âˆµ æ‰€æœ‰æ­£æ•´æ•°æœ€ç»ˆéƒ½å¯ä»¥ç”¨å¤šä¸ª1ç›¸åŠ å¾—åˆ°
    }

    /*
    * è¶…æ—¶è§£ï¼šDFS
    * - æ€è·¯ï¼šåŸºäºè§£æ³•1ä¸­çš„å›¾è®ºå»ºæ¨¡ï¼Œå…·ä½“å®ç°é‡‡ç”¨ DFSï¼ˆSEE: Play-with-algorithms/Graph/Path.java)ï¼Œå³é€šè¿‡ DFS ä» n é¡¶ç‚¹
    *   å¼€å§‹å‘0é¡¶ç‚¹æ–¹å‘é€’å½’ï¼Œæ²¿é€”ä¸ºæ¯ä¸ªé¡¶ç‚¹ i è®¡ç®—åˆ°è¾¾0çš„æœ€å°‘æ­¥æ•° f(i)ã€‚âˆµ å‰ä¸€é¡¶ç‚¹åˆ°è¾¾0çš„æœ€å°‘æ­¥æ•° = åä¸€é¡¶ç‚¹åˆ°è¾¾0çš„æœ€å°‘æ­¥æ•° + 1ï¼Œ
    *   ä¸”åä¸€é¡¶ç‚¹ä¸å‰ä¸€é¡¶ç‚¹ç›´æ¥å·®ä¸€ä¸ªå®Œå…¨å¹³æ–¹æ•° âˆ´ æœ‰ f(i) = min(f(i - s) + 1)ï¼Œå…¶ä¸­ s ä¸º <= i çš„å®Œå…¨å¹³æ–¹æ•°ã€‚
    * - æ—¶é—´å¤æ‚åº¦ O(n^n)ï¼Œç©ºé—´å¤æ‚åº¦ O(n)ã€‚
    * */
    public static int numSquares(int n) {
        if (n == 0) return 0;             // é¡¶ç‚¹0åˆ°è¾¾è‡ªå·±çš„æ­¥æ•°ä¸º0

        int minStep = Integer.MAX_VALUE;  // ç”¨äºè®°å½•å½“å‰é¡¶ç‚¹åˆ°0çš„æœ€å°æ­¥æ•°
        for (int i = 1; i * i <= n; i++)  // æ‰¾åˆ°å½“å‰é¡¶ç‚¹çš„ç›¸é‚»é¡¶ç‚¹
            minStep = Math.min(minStep, numSquares(n - i * i) + 1);  // è®¡ç®—æ‰€æœ‰ç›¸é‚»é¡¶ç‚¹åˆ°0çš„æœ€å°‘æ­¥æ•°ï¼Œå…¶ä¸­æœ€å°å€¼+1å³æ˜¯å½“å‰é¡¶ç‚¹åˆ°0çš„æœ€å°‘æ­¥æ•°

        return minStep;
    }

    /*
    * è§£æ³•2ï¼šRecursion + Memoizationï¼ˆDFS with cacheï¼‰
    * - æ€è·¯ï¼šğŸ‘†è¶…æ—¶è§£çš„é—®é¢˜åœ¨äºå¤§é‡å­é—®é¢˜ä¼šè¢«é‡å¤è®¡ç®— âˆ´ å¯ä»¥åŠ å…¥ Memoization æœºåˆ¶æ¥ä¼˜åŒ–é‡å å­é—®é¢˜ã€‚
    * - æ—¶é—´å¤æ‚åº¦ O(n)ï¼Œç©ºé—´å¤æ‚åº¦ O(n)ã€‚
    * */
    public static int numSquares2(int n) {
        int[] steps = new int[n + 1];         // ä¿å­˜æ¯ä¸ªé¡¶ç‚¹åˆ°è¾¾0çš„æœ€å°‘æ­¥æ•°ï¼ˆn+1 æ˜¯å› ä¸ºä» n åˆ° 0 éœ€è¦å¼€ n+1 çš„ç©ºé—´ï¼‰
        Arrays.fill(steps, -1);
        return numSquares2(n, steps);
    }

    private static int numSquares2(int n, int[] steps) {
        if (n == 0) return 0;
        if (steps[n] != -1) return steps[n];  // cache hit

        int minStep = Integer.MAX_VALUE;
        for (int i = 1; i * i <= n; i++)
            minStep = Math.min(minStep, numSquares2(n - i * i, steps) + 1);

        return steps[n] = minStep;            // èµ‹å€¼è¯­å¥çš„è¿”å›å€¼ä¸ºæ‰€èµ‹çš„å€¼
    }

    /*
    * è§£æ³•3ï¼šDP (bottom-up iteration)
    * - æ€è·¯ï¼š
    *   - ç±»ä¼¼ DP/Fibonacci ä¸­è§£æ³•3çš„è‡ªä¸‹è€Œä¸Šçš„æ±‚è§£æ€è·¯ã€‚
    *   - ä¸è§£æ³•2éƒ½æ˜¯åŸºäºå·²è§£å†³çš„å­é—®é¢˜å»è§£å†³é«˜å±‚æ¬¡çš„é—®é¢˜ï¼Œä½†ä¸åŒç‚¹åœ¨äºè¯¥è§£æ³•æ˜¯ bottom-up çš„ï¼Œå³ç›´æ¥ä»å­é—®é¢˜å¼€å§‹æ±‚è§£ï¼Œè€Œè§£æ³•2æ˜¯
    *     ä»é«˜å±‚æ¬¡é—®é¢˜å…¥æ‰‹ï¼Œé€’å½’åˆ°æœ€åº•å±‚é—®é¢˜åå†å¼€å§‹é€å±‚è§£å†³ã€‚
    * - DP ä¸ Memoization çš„åŒºåˆ« SEE: https://zhuanlan.zhihu.com/p/68059061ã€‚
    * - æ—¶é—´å¤æ‚åº¦ O(n)ï¼Œç©ºé—´å¤æ‚åº¦ O(n)ã€‚
    * */
    public static int numSquares3(int n) {
        int[] steps = new int[n + 1];
        Arrays.fill(steps, Integer.MAX_VALUE);
        steps[0] = 0;

        for (int v = 1; v <= n; v++)  // ä¸º [1, n] ä¸­çš„æ‰€æœ‰å…ƒç´ è®¡ç®—åˆ°è¾¾0çš„æœ€å°æ­¥æ•°ï¼ˆè®¡ç®—æ˜¯ä»1å¼€å§‹çš„ï¼Œä½“ç° bottom-up çš„ç†å¿µï¼‰
            for (int i = 1; v - i * i >= 0; i++)  // å¤–å±‚å¾ªç¯ç¡®å®šäº†é¡¶ç‚¹åï¼Œåœ¨å†…å±‚å¾ªç¯ä¸­è®¡ç®—è¯¥é¡¶ç‚¹çš„æœ€å°æ­¥æ•°
                steps[v] = Math.min(steps[v], steps[v - i * i] + 1);

        return steps[n];              // æœ€åè¿”å› n çš„ step
    }

    public static void main(String[] args) {
        log(numSquares2(5));   // expects 2. (5 = 4 + 1)
        log(numSquares2(6));   // expects 3. (6 = 4 + 1 + 1)
        log(numSquares2(12));  // expects 3. (12 = 4 + 4 + 4)
        log(numSquares2(13));  // expects 2. (13 = 4 + 9)
    }
}
