package DP.S3_StateTransition;

import static Utils.Helpers.log;

import java.util.Arrays;

/*
 * House Robber
 *
 * - You are a professional robber planning to rob houses along a street where each house has a certain amount
 *   of money stashed. However if two adjacent houses were broken into on the same night, the security system
 *   will go off and the police will be alerted.
 *
 * - Given a list of non-negative integers representing the amount of money of each house, determine the
 *   maximum amount of money you can rob tonight without alerting the police.
 *
 * - â­ æ€»ç»“ï¼šå‡½æ•°å®šä¹‰ã€çŠ¶æ€ã€çŠ¶æ€è½¬ç§»ï¼š
 *   1. è§£æ³•1é‡‡ç”¨äº†é€’å½’ï¼Œå…¶ tryToRob æ–¹æ³•ç”¨äºâ€œè®¡ç®—ä»æŸä¸ªèŒƒå›´å†…çš„æˆ¿å­ä¸­èƒ½å·å¾—çš„æœ€å¤§æ”¶è·â€ï¼Œè¿™å°±æ˜¯é€’å½’ä¸­çš„â€œå‡½æ•°å®šä¹‰â€ã€‚æ˜ç¡®åˆç†çš„å‡½æ•°
 *      å®šä¹‰å¯¹äºå†™å‡ºæ­£ç¡®çš„é€’å½’é€»è¾‘è‡³å…³é‡è¦ã€‚
 *   2. è§£æ³•2ã€3é‡‡ç”¨äº† DPï¼Œè€Œâ€œå‡½æ•°å®šä¹‰â€åœ¨ DP ä¸­çš„å¯¹åº”æ¦‚å¿µæ˜¯â€œçŠ¶æ€â€ï¼Œä¾‹å¦‚â€œ[0..n)å†…çš„æœ€å¤§æ”¶è·â€å°±æ˜¯è¯¥é—®é¢˜çš„é¡¶å±‚çŠ¶æ€ï¼Œç”±äºåœ¨è¯¥çŠ¶æ€
 *      ä¸‹é‡‡å–äº†ä¸åŒçš„è¡ŒåŠ¨ï¼ˆå·0å·ã€å·1å·â€¦â€¦ï¼‰ï¼Œè¯¥é—®é¢˜çš„çŠ¶æ€å‘ç”Ÿäº†è½¬ç§»ï¼Œäº§ç”Ÿäº†å…¶ä»–3ä¸ªå¯èƒ½çš„çŠ¶æ€ã€‚è€Œæè¿°æ¸…æ¥šè¿™äº›çŠ¶æ€ä¹‹é—´çš„è½¬ç§»æ–¹å¼ï¼ˆå³
 *      æ˜ç¡®çš„â€œçŠ¶æ€è½¬ç§»æ–¹ç¨‹â€ï¼‰å¯¹äºå†™å‡ºæ­£ç¡®çš„ DP é€»è¾‘è‡³å…³é‡è¦ã€‚ä¾‹å¦‚ï¼Œè¯¥é—®é¢˜çš„çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š
 *      f(0..n-1) = max(v(0)+f(1..n-1), v(1)+f(3..n-1), v(3)+f(5..n-1), ..., v(n-1))ï¼Œå…¶ä¸­ f ä¸ºâ€œæŸåŒºé—´å†…çš„æœ€å¤§æ”¶è·â€ï¼Œ
 *      v ä¸ºæŸæˆ¿å­çš„æ”¶è·ã€‚
 * */

public class L198_HouseRobber {
    /*
     * è¶…æ—¶è§£ï¼šBrute Force
     * - æ€è·¯ï¼šè¯¥é¢˜çš„æœ¬è´¨æ˜¯ä¸€ä¸ªç»„åˆä¼˜åŒ–é—®é¢˜ â€”â€” åœ¨æ‰€æœ‰æˆ¿å­ä¸­ï¼Œå“ªå‡ ä¸ªæˆ¿å­çš„ç»„åˆèƒ½æ»¡è¶³æ¡ä»¶ï¼š1.æˆ¿å­ä¹‹é—´å„ä¸ç›¸é‚» 2.æ”¶è·æœ€å¤§åŒ–ã€‚
     *   å› æ­¤å¯ä»¥éå†æ‰€æœ‰æˆ¿å­çš„ç»„åˆï¼Œä»ç¬¦åˆæ¡ä»¶çš„ç»„åˆä¸­æ‰¾åˆ°æœ€å¤§çš„æ”¶è·ã€‚
     * - æ—¶é—´å¤æ‚åº¦ O((2^n)*n)ã€‚âˆµ æ¯ä¸ªæˆ¿å­æœ‰å·/ä¸å·2ç§å¯èƒ½ï¼Œn ä¸ªæˆ¿å­å…±æœ‰ 2^n ç§ç»„åˆ âˆ´ éå†æ‰€æœ‰ç»„åˆå°±æ˜¯ O(2^n) æ“ä½œï¼›ä»æ‰€æœ‰
     *   ç»„åˆä¸­ç­›å‡ºç¬¦åˆæ¡ä»¶1çš„ç»„åˆæ˜¯ O(n) æ“ä½œ âˆ´ æ•´ä½“æ˜¯ O((2^n)*n)ã€‚
     * */

    /*
     * è§£æ³•1ï¼šRecursion + Memoization (DFS with cache)
     * - æ€è·¯ï¼šç±»ä¼¼ L343_IntegerBreak è§£æ³•1çš„æ€è·¯ï¼Œå¯¹é—®é¢˜è¿›è¡Œåˆ†è§£ï¼šf(i) è¡¨ç¤ºâ€œä» [i,n) åŒºé—´å†…çš„æˆ¿å­ä¸­æ‰€èƒ½å¾—åˆ°çš„æœ€å¤§æ”¶è·â€ï¼Œ
     *   åˆ™å¯¹äº nums=[3, 4, 1, 2] æ¥è¯´ï¼š
     *                                            f(0)
     *                       æŠ¢[0]/       æŠ¢[1]/     æŠ¢[2]\      æŠ¢[3]\
     *                        f(2)          f(3)       nums[2]    nums[3]
     *                  æŠ¢[2]/   \æŠ¢[3]   æŠ¢[3]|
     *                 nums[2]  nums[3]    nums[3]
     *
     *   å…¬å¼è¡¨è¾¾ï¼šf(0) = max(nums[0]+f(2), nums[1]+f(3), nums[2], nums[3])
     *                = max(nums[0]+nums[2], nums[1]+nums[3]), nums[2], nums[3])
     *                = max(3+2, 4+2, 2, 2)
     *                = 6
     *   æ€»ç»“ä¸€ä¸‹ï¼š
     *     - å­é—®é¢˜å®šä¹‰ï¼šf(i) è¡¨ç¤ºâ€œä» [i,n) åŒºé—´å†…çš„æˆ¿å­ä¸­æ‰€èƒ½å¾—åˆ°çš„æœ€å¤§æ”¶è·â€ï¼›
     *     - é€’æ¨è¡¨è¾¾å¼ï¼šf(i) = max(num[j] + f(j + 2))ï¼Œå…¶ä¸­ i âˆˆ [0,n)ï¼Œj âˆˆ [i,n-2)ã€‚
     *   è¿™æ ·çš„åˆ†è§£å¯ä»¥å¾ˆè‡ªç„¶çš„ä½¿ç”¨é€’å½’å®ç°ï¼Œåˆ âˆµ åˆ†è§£è¿‡ç¨‹ä¸­å­˜åœ¨é‡å å­é—®é¢˜ âˆ´ å¯ä½¿ç”¨ memoization è¿›è¡Œä¼˜åŒ–ã€‚
     * - æ—¶é—´å¤æ‚åº¦ O(n)ï¼Œç©ºé—´å¤æ‚åº¦ O(n)ã€‚
     * */
    public static int rob1(int[] nums) {
        if (nums == null || nums.length == 0) return 0;
        int[] cache = new int[nums.length + 1];
        Arrays.fill(cache, -1);           // âˆµ æ”¶è·å¯èƒ½ä¸º0 âˆ´ åˆå§‹åŒ–ä¸º-1
        return tryToRob(nums, 0, cache);
    }

    private static int tryToRob(int[] nums, int i, int[] cache) {  // è®¡ç®— [i..n) å†…çš„æœ€å¤§æ”¶è·
        if (i >= nums.length) return 0;
        if (cache[i] != -1) return cache[i];

        int res = 0;
        for (int j = i; j < nums.length; j++)  // èŒƒå›´å›ºå®šçš„æƒ…å†µä¸‹ï¼Œçœ‹å“ªç§æ–¹æ¡ˆæ”¶è·æœ€å¤§ï¼Œä¾‹ï¼šåœ¨ [2,4,5] å†…ï¼Œæ˜¯æŠ¢ 2+4 æ”¶è·å¤§ï¼Œè¿˜æ˜¯ 3+5ï¼Œè¿˜æ˜¯ 2+5
            res = Math.max(res, nums[j] + tryToRob(nums, j + 2, cache));  // è¿™é‡Œä¸ç”¨ç®¡ j+2 è¶Šç•Œé—®é¢˜ âˆµ ä¸Šé¢ i >= nums.length å·²ç»å¤„ç†äº†

        return cache[i] = res;
    }

    /*
     * è§£æ³•2ï¼šDP
     * - æ€è·¯ï¼šç›´æ¥å°†è§£æ³•1è½¬æ¢ä¸º DP å†™æ³•ï¼ˆä»ç„¶æ˜¯ä»ä¸Šåˆ°ä¸‹åˆ†è§£ä»»åŠ¡çš„æ€è·¯ï¼‰ã€‚
     * - æ—¶é—´å¤æ‚åº¦ O(n)ï¼Œç©ºé—´å¤æ‚åº¦ O(n)ã€‚
     * */
    public static int rob2(int[] nums) {
        if (nums == null || nums.length == 0) return 0;

        int n = nums.length;
        int[] dp = new int[n + 1];
        dp[n - 1] = nums[n - 1];          // å…ˆè§£ç­”æœ€åä¸€ä¸ªé—®é¢˜ï¼Œå³å· n-1 å·çš„æ”¶è·

        for (int i = n - 2; i >= 0; i--)  // è®¡ç®— [i..n) å†…çš„æœ€å¤§æ”¶è·
            for (int j = i; j < n; j++)   // èŒƒå›´å›ºå®šçš„æƒ…å†µä¸‹ï¼Œçœ‹å“ªç§æ–¹æ¡ˆæ”¶è·æœ€å¤§
                dp[i] = Math.max(dp[i], nums[j] + (j + 2 < n ? dp[j + 2] : 0));

        return dp[0];
    }

    /*
     * è§£æ³•3ï¼šDP
     * - æ€è·¯ï¼šå¦ä¸€ç§æ€è·¯æ˜¯ï¼šâˆµ æ¯ä¸ªæˆ¿å­éƒ½æœ‰å·/ä¸å·ä¸¤ç§é€‰æ‹© âˆ´ åªè¦å–å…¶ä¸­æ”¶ç›Šæœ€å¤§çš„é€‰æ‹©å³å¯ã€‚å¯¹äº nums=[3, 4, 1, 2] æ¥è¯´ï¼š
     *   f(0) = max(nums[0] + f(2), f(1))ï¼Œå…¶ä¸­ f(2) = nums[2] = 2ï¼›
     *   f(1) = max(nums[1] + f(3), f(2))ï¼Œå…¶ä¸­ f(3) = nums[3] = 2ï¼›
     *   âˆ´ f(0) = max(3+2, 4+2) = 6ã€‚
     *   æ€»ç»“ä¸€ä¸‹ï¼š
     *     - å­é—®é¢˜å®šä¹‰ï¼šf(i) è¡¨ç¤ºâ€œä» [i,n) åŒºé—´å†…çš„æˆ¿å­ä¸­æ‰€èƒ½å¾—åˆ°çš„æœ€å¤§æ”¶è·â€ï¼›
     *     - é€’æ¨è¡¨è¾¾å¼ï¼šf(i) = max(num[0] + f(2), f(1))ã€‚
     * - ğŸ’æ€»ç»“ï¼šå¯è§è¯¥æ€è·¯ä¸è§£æ³•1ã€2çš„ä¸åŒä¹‹å¤„åœ¨äºä¸ç”¨éå†æ‰€æœ‰å¯èƒ½æ€§ï¼Œåªè€ƒè™‘ç¬¬ä¸€ä¸ªæˆ¿å­æŠ¢/ä¸æŠ¢å³å¯ã€‚
     * - æ—¶é—´å¤æ‚åº¦ O(n)ï¼Œç©ºé—´å¤æ‚åº¦ O(n)ã€‚
     * */
    public static int rob3(int[] nums) {
        if (nums == null || nums.length == 0) return 0;

        int n = nums.length;
        int[] dp = new int[n + 1];
        dp[n] = 0;
        dp[n - 1] = nums[n - 1];

        for (int i = n - 2; i >= 0; i--)
            dp[i] = Math.max(dp[i + 2] + nums[i], dp[i + 1]);

        return dp[0];
    }

    /*
     * è§£æ³•4ï¼šæ›´è‡ªç„¶çš„ DP
     * - æ€è·¯ï¼šè§£æ³•2çš„ DP æ€è·¯æ˜¯ç”±è§£æ³•1å†åå‘æ€è€ƒåå¾—åˆ°çš„ã€‚è€Œæ›´è‡ªç„¶çš„ DP æ€è·¯æ˜¯ï¼šâˆµ æ¯ä¸ªæˆ¿å­éƒ½æœ‰å·/ä¸å·ä¸¤ç§é€‰æ‹© âˆ´ å¯ä»¥æœ‰ï¼š
     *   - å®šä¹‰å­é—®é¢˜ï¼šf(i) è¡¨ç¤ºâ€œä»å‰ i æ‰€æˆ¿å­ä¸­æ‰€èƒ½å¾—åˆ°çš„æœ€å¤§æ”¶è·â€ï¼›
     *   - çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼šf(i) = max(nums[i] + f(i-2), f(i-1))ã€‚å…¶ä¸­ nums[i] + f(i-2) ä¸ºå·ç¬¬ i æ‰€æˆ¿å­çš„æœ€å¤§æ”¶è·ï¼Œf(i-1)
     *     ä¸ºä¸å·ç¬¬ i æ‰€æˆ¿å­çš„æœ€å¤§æ”¶è·ã€‚
     * - æ—¶é—´å¤æ‚åº¦ O(n)ï¼Œç©ºé—´å¤æ‚åº¦ O(n)ã€‚
     * */
    public static int rob4(int[] nums) {
        if (nums == null || nums.length == 0) return 0;

        int n = nums.length;
        if (n == 1) return nums[0];                     // åªæœ‰1ä¸ªæˆ¿å­çš„æƒ…å†µ
        if (n == 2) return Math.max(nums[0], nums[1]);  // åªæœ‰2ä¸ªæˆ¿å­çš„æƒ…å†µ

        int[] dp = new int[n];                          // æœ‰å¤šäº2ä¸ªæˆ¿å­çš„æƒ…å†µ
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);

        for (int i = 2; i < dp.length; i++)
            dp[i] = Math.max(nums[i] + dp[i - 2], dp[i - 1]);

        return dp[n - 1];
    }

    /*
     * è§£æ³•5ï¼šDPï¼ˆå¤šçŠ¶æ€é€’æ¨æ€è·¯ï¼‰
     * - æ€è·¯ï¼šè§£æ³•3çš„æ€è·¯æ˜¯å°† f(i) å®šä¹‰ä¸ºâ€œä»å‰ i æ‰€æˆ¿å­ä¸­æ‰€èƒ½å¾—åˆ°çš„æœ€å¤§æ”¶è·â€ï¼Œè¿™é‡ŒåŒæ—¶åŒ…å«äº†å·ä»¥åŠä¸å· i è¿™2ç§æƒ…å†µã€‚å¦ä¸€ç§æ€è·¯
     *   æ˜¯é€šè¿‡æ¢³ç†ä¸åŒè¡Œä¸ºå¯¹çŠ¶æ€çš„å½±å“å†™å‡ºä¸åŒçŠ¶æ€çš„é€’æ¨è¡¨è¾¾å¼ï¼ˆå°†å·/ä¸å·è¿™2ç§è¡Œä¸ºå¯¹åº”çš„çŠ¶æ€åˆ†å¼€è¿›è¡Œé€’æ¨ï¼‰ï¼š
     *   - y(i) è¡¨ç¤ºâ€œè‹¥å·ç¬¬ i æ‰€æˆ¿å­ï¼Œåˆ™ä»å‰ i æ‰€æˆ¿å­ä¸­èƒ½è·å¾—çš„æœ€å¤§æ”¶è·â€ï¼šy(i) = n(i-1) + nums[i]ï¼›
     *   - n(i) è¡¨ç¤ºâ€œè‹¥ä¸å·ç¬¬ i æ‰€æˆ¿å­ï¼Œåˆ™ä»å‰ i æ‰€æˆ¿å­ä¸­èƒ½è·å¾—çš„æœ€å¤§æ”¶è·â€ï¼šn(i) = max(y(i-1), n(i-1))ã€‚
     *   æœ€ååªè¦å– max(y(i), n(i)) å³å¾—åˆ°åŸé—®é¢˜çš„è§£ã€‚
     * - æ—¶é—´å¤æ‚åº¦ O(n)ï¼Œç©ºé—´å¤æ‚åº¦ O(1)ã€‚
     * */
    public static int rob5(int[] nums) {
        int prevNo = 0;           // å·å‰ä¸€é—´çš„æœ€å¤§æ”¶è·
        int prevYes = 0;          // ä¸å·å‰ä¸€é—´çš„æœ€å¤§æ”¶è·

        for (int n : nums) {      // ä»ç¬¬ä¸€é—´æˆ¿å­å¼€å§‹å¯¹è®¡ç®—æ¯é—´æˆ¿å­åœ¨å·/ä¸å·æ—¶çš„æœ€å¤§æ”¶è·
            int currYes = prevNo + n;
            int currNo = Math.max(prevNo, prevYes);  // ä¸å·è¿™é—´å¹¶ä¸æ„å‘³ç€ä¸€å®šè¦å·å‰ä¸€é—´
            prevNo = currNo;      // å‰é˜µå˜åé˜µ
            prevYes = currYes;
        }

        return Math.max(prevNo, prevYes);
    }

    public static void main(String[] args) {
        log(rob2(new int[]{3, 4, 1, 2}));     // expects 6.  [3, (4), 1, (2)]
        log(rob2(new int[]{4, 3, 1, 2}));     // expects 6.  [(4), 3, 1, (2)]
        log(rob2(new int[]{1, 2, 3, 1}));     // expects 4.  [(1), 2, (3), 1].
        log(rob2(new int[]{2, 7, 9, 3, 1}));  // expects 12. [(2), 7, (9), 3, (1)]
    }
}